 (see [HELP CALL]).\nTo invoke a stored function, refer to it in an expression. The function\nreturns a value during expression evaluation.\n\nCREATE PROCEDURE and CREATE FUNCTION require the CREATE ROUTINE\nprivilege. If the DEFINER clause is present, the privileges required\ndepend on the user value, as discussed in\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-objects-security.html.\nIf binary logging is enabled, CREATE FUNCTION might require the SUPER\nprivilege, as discussed in\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-programs-logging.html.\n\nBy default, MySQL automatically grants the ALTER ROUTINE and EXECUTE\nprivileges to the routine creator. This behavior can be changed by\ndisabling the automatic_sp_privileges system variable. See\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-routines-privileges.html\n.\n\nThe DEFINER and SQL SECURITY clauses specify the security context to be\nused when checking access privileges at routine execution time, as\ndescribed later in this section.\n\nIf the routine name is the same as the name of a built-in SQL function,\na syntax error occurs unless you use a space between the name and the\nfollowing parenthesis when defining the routine or invoking it later.\nFor this reason, avoid using the names of existing SQL functions for\nyour own stored routines.\n\nThe IGNORE_SPACE SQL mode applies to built-in functions, not to stored\nroutines. It is always permissible to have spaces after a stored\nroutine name, regardless of whether IGNORE_SPACE is enabled.\n\nIF NOT EXISTS prevents an error from occurring if there already exists\na routine with the same name. This option is supported with both CREATE\nFUNCTION and CREATE PROCEDURE.\n\nIf a built-in function with the same name already exists, attempting to\ncreate a stored function with CREATE FUNCTION ... IF NOT EXISTS\nsucceeds with a warning indicating that it has the same name as a\nnative function; this is no different than when performing the same\nCREATE FUNCTION statement without specifying IF NOT EXISTS.\n\nIf a loadable function with the same name already exists, attempting to\ncreate a stored function using IF NOT EXISTS succeeds with a warning.\nThis is the same as without specifying IF NOT EXISTS.\n\nSee\nhttps://dev.mysql.com/doc/refman/8.4/en/function-resolution.html#functi\non-name-resolution, for more information.\n\nThe parameter list enclosed within parentheses must always be present.\nIf there are no parameters, an empty parameter list of () should be\nused. Parameter names are not case-sensitive.\n\nEach parameter is an IN parameter by default. To specify otherwise for\na parameter, use the keyword OUT or INOUT before the parameter name.\n\n*Note*:\n\nSpecifying a parameter as IN, OUT, or INOUT is valid only for a\nPROCEDURE. For a FUNCTION, parameters are always regarded as IN\nparameters.\n\nAn IN parameter passes a value into a procedure. The procedure might\nmodify the value, but the modification is not visible to the caller\nwhen the procedure returns. An OUT parameter passes a value from the\nprocedure back to the caller. Its initial value is NULL within the\nprocedure, and its value is visible to the caller when the procedure\nreturns. An INOUT parameter is initialized by the caller, can be\nmodified by the procedure, and any change made by the procedure is\nvisible to the caller when the procedure returns.\n\nFor each OUT or INOUT parameter, pass a user-defined variable in the\nCALL statement that invokes the procedure so that you can obtain its\nvalue when the procedure returns. If you are calling the procedure from\nwithin another stored procedure or function, you can also pass a\nroutine parameter or local routine variable as an OUT or INOUT\nparameter. If you are calling the procedure from within a trigger, you\ncan also pass NEW.col_name as an OUT or INOUT parameter.\n\nFor information about the effect of unhandled conditions on procedure\nparameters, see\nhttps://dev.mysql.com/doc/refman/8.4/en/conditions-and-parameters.html.\n\nRoutine parameters cannot be referenced in statements prepared within\nthe routine; see\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-program-restrictions.html\n.\n\nThe following example shows a simple stored procedure that, given a\ncountry code, counts the number of cities for that country that appear\nin the city table of the world database. The country code is passed\nusing an IN parameter, and the city count is returned using an OUT\nparameter:\n\nmysql> delimiter //\n\nmysql> CREATE PROCEDURE citycount (IN country CHAR(3), OUT cities INT)\n       BEGIN\n         SELECT COUNT(*) INTO cities FROM world.city\n         WHERE CountryCode = country;\n       END//\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> delimiter ;\n\nmysql> CALL citycount(\'JPN\', @cities); -- cities in Japan\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|     248 |\n+---------+\n1 row in set (0.00 sec)\n\nmysql> CALL citycount(\'FRA\', @cities); -- cities in France\nQuery OK, 1 row affected (0.00 sec)\n\nmysql> SELECT @cities;\n+---------+\n| @cities |\n+---------+\n|      40 |\n+---------+\n1 row in set (0.00 sec)\n\nThe example uses the mysql client delimiter command to change the\nstatement delimiter from ; to // while the procedure is being defined.\nThis enables the ; delimiter used in the procedure body to be passed\nthrough to the server rather than being interpreted by mysql itself.\nSee\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-programs-defining.html.\n\nThe RETURNS clause may be specified only for a FUNCTION, for which it\nis mandatory. It indicates the return type of the function, and the\nfunction body must contain a RETURN value statement. If the RETURN\nstatement returns a value of a different type, the value is coerced to\nthe proper type. For example, if a function specifies an ENUM or SET\nvalue in the RETURNS clause, but the RETURN statement returns an\ninteger, the value returned from the function is the string for the\ncorresponding ENUM member of set of SET members.\n\nThe following example function takes a parameter, performs an operation\nusing an SQL function, and returns the result. In this case, it is\nunnecessary to use delimiter because the function definition contains\nno internal ; statement delimiters:\n\nmysql> CREATE FUNCTION hello (s CHAR(20))\nmysql> RETURNS CHAR(50) DETERMINISTIC\n       RETURN CONCAT(\'Hello, \',s,\'!\');\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> SELECT hello(\'world\');\n+----------------+\n| hello(\'world\') |\n+----------------+\n| Hello, world!  |\n+----------------+\n1 row in set (0.00 sec)\n\nParameter types and function return types can be declared to use any\nvalid data type. The COLLATE attribute can be used if preceded by a\nCHARACTER SET specification.\n\nThe routine_body consists of a valid SQL routine statement. This can be\na simple statement such as SELECT or INSERT, or a compound statement\nwritten using BEGIN and END. Compound statements can contain\ndeclarations, loops, and other control structure statements. The syntax\nfor these statements is described in\nhttps://dev.mysql.com/doc/refman/8.4/en/sql-compound-statements.html.\nIn practice, stored functions tend to use compound statements, unless\nthe body consists of a single RETURN statement.\n\nMySQL permits routines to contain DDL statements, such as CREATE and\nDROP. MySQL also permits stored procedures (but not stored functions)\nto contain SQL transaction statements such as COMMIT. Stored functions\nmay not contain statements that perform explicit or implicit commit or\nrollback. Support for these statements is not required by the SQL\nstandard, which states that each DBMS vendor may decide whether to\npermit them.\n\nStatements that return a result set can be used within a stored\nprocedure but not within a stored function. This prohibition includes\nSELECT statements that do not have an INTO var_list clause and other\nstatements such as SHOW, EXPLAIN, and CHECK TABLE. For statements that\ncan be determined at function definition time to return a result set, a\nNot allowed to return a result set from a function error occurs\n(ER_SP_NO_RETSET\n(https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html\n#error_er_sp_no_retset)). For statements that can be determined only\nat runtime to return a result set, a PROCEDURE %s can\'t return a result\nset in the given context error occurs (ER_SP_BADSELECT\n(https://dev.mysql.com/doc/mysql-errors/8.4/en/server-error-reference.html\n#error_er_sp_badselect)).\n\nUSE statements within stored routines are not permitted. When a routine\nis invoked, an implicit USE db_name is performed (and undone when the\nroutine terminates). The causes the routine to have the given default\ndatabase while it executes. References to objects in databases other\nthan the routine default database should be qualified with the\nappropriate database name.\n\nFor additional information about statements that are not permitted in\nstored routines, see\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-program-restrictions.html\n.\n\nFor information about invoking stored procedures from within programs\nwritten in a language that has a MySQL interface, see [HELP CALL].\n\nMySQL stores the sql_mode system variable setting in effect when a\nroutine is created or altered, and always executes the routine with\nthis setting in force, regardless of the current server SQL mode when\nthe routine begins executing.\n\nThe switch from the SQL mode of the invoker to that of the routine\noccurs after evaluation of arguments and assignment of the resulting\nvalues to routine parameters. If you define a routine in strict SQL\nmode but invoke it in nonstrict mode, assignment of arguments to\nroutine parameters does not take place in strict mode. If you require\nthat expressions passed to a routine be assigned in strict SQL mode,\nyou should invoke the routine with strict mode in effect.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-procedure.html\n\n','','https://dev.mysql.com/doc/refman/8.4/en/create-procedure.html'),(519,'CREATE SERVER',40,'Syntax:\nCREATE SERVER server_name\n    FOREIGN DATA WRAPPER wrapper_name\n    OPTIONS (option [, option] ...)\n\noption: {\n    HOST character-literal\n  | DATABASE character-literal\n  | USER character-literal\n  | PASSWORD character-literal\n  | SOCKET character-literal\n  | OWNER character-literal\n  | PORT numeric-literal\n}\n\nThis statement creates the definition of a server for use with the\nFEDERATED storage engine. The CREATE SERVER statement creates a new row\nin the servers table in the mysql database. This statement requires the\nSUPER privilege.\n\nThe server_name should be a unique reference to the server. Server\ndefinitions are global within the scope of the server, it is not\npossible to qualify the server definition to a specific database.\nserver_name has a maximum length of 64 characters (names longer than 64\ncharacters are silently truncated), and is case-insensitive. You may\nspecify the name as a quoted string.\n\nThe wrapper_name is an identifier and may be quoted with single\nquotation marks.\n\nFor each option you must specify either a character literal or numeric\nliteral. Character literals are UTF-8, support a maximum length of 64\ncharacters and default to a blank (empty) string. String literals are\nsilently truncated to 64 characters. Numeric literals must be a number\nbetween 0 and 9999, default value is 0.\n\n*Note*:\n\nThe OWNER option is currently not applied, and has no effect on the\nownership or operation of the server connection that is created.\n\nThe CREATE SERVER statement creates an entry in the mysql.servers table\nthat can later be used with the CREATE TABLE statement when creating a\nFEDERATED table. The options that you specify are used to populate the\ncolumns in the mysql.servers table. The table columns are Server_name,\nHost, Db, Username, Password, Port and Socket.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-server.html\n\n','CREATE SERVER s\nFOREIGN DATA WRAPPER mysql\nOPTIONS (USER \'Remote\', HOST \'198.51.100.106\', DATABASE \'test\');\n','https://dev.mysql.com/doc/refman/8.4/en/create-server.html'),(520,'CREATE SPATIAL REFERENCE SYSTEM',40,'Syntax:\nCREATE OR REPLACE SPATIAL REFERENCE SYSTEM\n    srid srs_attribute ...\n\nCREATE SPATIAL REFERENCE SYSTEM\n    [IF NOT EXISTS]\n    srid srs_attribute ...\n\nsrs_attribute: {\n    NAME \'srs_name\'\n  | DEFINITION \'definition\'\n  | ORGANIZATION \'org_name\' IDENTIFIED BY org_id\n  | DESCRIPTION \'description\'\n}\n\nsrid, org_id: 32-bit unsigned integer\n\nThis statement creates a spatial reference system (SRS) definition and\nstores it in the data dictionary. It requires the SUPER privilege. The\nresulting data dictionary entry can be inspected using the\nINFORMATION_SCHEMA ST_SPATIAL_REFERENCE_SYSTEMS table.\n\nSRID values must be unique, so if neither OR REPLACE nor IF NOT EXISTS\nis specified, an error occurs if an SRS definition with the given srid\nvalue already exists.\n\nWith CREATE OR REPLACE syntax, any existing SRS definition with the\nsame SRID value is replaced, unless the SRID value is used by some\ncolumn in an existing table. In that case, an error occurs. For\nexample:\n\nmysql> CREATE OR REPLACE SPATIAL REFERENCE SYSTEM 4326 ...;\nERROR 3716 (SR005): Can\'t modify SRID 4326. There is at\nleast one column depending on it.\n\nTo identify which column or columns use the SRID, use this query,\nreplacing 4326 with the SRID of the definition you are trying to\ncreate:\n\nSELECT * FROM INFORMATION_SCHEMA.ST_GEOMETRY_COLUMNS WHERE SRS_ID=4326;\n\nWith CREATE ... IF NOT EXISTS syntax, any existing SRS definition with\nthe same SRID value causes the new definition to be ignored and a\nwarning occurs.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-spatial-reference-system.html\n\n','CREATE SPATIAL REFERENCE SYSTEM 4120\nNAME \'Greek\'\nORGANIZATION \'EPSG\' IDENTIFIED BY 4120\nDEFINITION\n  \'GEOGCS[\"Greek\",DATUM[\"Greek\",SPHEROID[\"Bessel 1841\",\n  6377397.155,299.1528128,AUTHORITY[\"EPSG\",\"7004\"]],\n  AUTHORITY[\"EPSG\",\"6120\"]],PRIMEM[\"Greenwich\",0,\n  AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.017453292519943278,\n  AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Lat\",NORTH],AXIS[\"Lon\",EAST],\n  AUTHORITY[\"EPSG\",\"4120\"]]\';\n','https://dev.mysql.com/doc/refman/8.4/en/create-spatial-reference-system.html'),(521,'CREATE TABLE',40,'Syntax:\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    (create_definition,...)\n    [table_options]\n    [partition_options]\n\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    [(create_definition,...)]\n    [table_options]\n    [partition_options]\n    [IGNORE | REPLACE]\n    [AS] query_expression\n\nCREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name\n    { LIKE old_tbl_name | (LIKE old_tbl_name) }\n\ncreate_definition: {\n    col_name column_definition\n  | {INDEX | KEY} [index_name] [index_type] (key_part,...)\n      [index_option] ...\n  | {FULLTEXT | SPATIAL} [INDEX | KEY] [index_name] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] PRIMARY KEY\n      [index_type] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY]\n      [index_name] [index_type] (key_part,...)\n      [index_option] ...\n  | [CONSTRAINT [symbol]] FOREIGN KEY\n      [index_name] (col_name,...)\n      reference_definition\n  | check_constraint_definition\n}\n\ncolumn_definition: {\n    data_type [NOT NULL | NULL] [DEFAULT {literal | (expr)} ]\n      [VISIBLE | INVISIBLE]\n      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]\n      [COMMENT \'string\']\n      [COLLATE collation_name]\n      [COLUMN_FORMAT {FIXED | DYNAMIC | DEFAULT}]\n      [ENGINE_ATTRIBUTE [=] \'string\']\n      [SECONDARY_ENGINE_ATTRIBUTE [=] \'string\']\n      [STORAGE {DISK | MEMORY}]\n      [reference_definition]\n      [check_constraint_definition]\n  | data_type\n      [COLLATE collation_name]\n      [GENERATED ALWAYS] AS (expr)\n      [VIRTUAL | STORED] [NOT NULL | NULL]\n      [VISIBLE | INVISIBLE]\n      [UNIQUE [KEY]] [[PRIMARY] KEY]\n      [COMMENT \'string\']\n      [reference_definition]\n      [check_constraint_definition]\n}\n\ndata_type:\n    (see https://dev.mysql.com/doc/refman/8.4/en/data-types.html)\n\nkey_part: {col_name [(length)] | (expr)} [ASC | DESC]\n\nindex_type:\n    USING {BTREE | HASH}\n\nindex_option: {\n    KEY_BLOCK_SIZE [=] value\n  | index_type\n  | WITH PARSER parser_name\n  | COMMENT \'string\'\n  | {VISIBLE | INVISIBLE}\n  |ENGINE_ATTRIBUTE [=] \'string\'\n  |SECONDARY_ENGINE_ATTRIBUTE [=] \'string\'\n}\n\ncheck_constraint_definition:\n    [CONSTRAINT [symbol]] CHECK (expr) [[NOT] ENFORCED]\n\nreference_definition:\n    REFERENCES tbl_name (key_part,...)\n      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]\n      [ON DELETE reference_option]\n      [ON UPDATE reference_option]\n\nreference_option:\n    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT\n\ntable_options:\n    table_option [[,] table_option] ...\n\ntable_option: {\n    AUTOEXTEND_SIZE [=] value\n  | AUTO_INCREMENT [=] value\n  | AVG_ROW_LENGTH [=] value\n  | [DEFAULT] CHARACTER SET [=] charset_name\n  | CHECKSUM [=] {0 | 1}\n  | [DEFAULT] COLLATE [=] collation_name\n  | COMMENT [=] \'string\'\n  | COMPRESSION [=] {\'ZLIB\' | \'LZ4\' | \'NONE\'}\n  | CONNECTION [=] \'connect_string\'\n  | {DATA | INDEX} DIRECTORY [=] \'absolute path to directory\'\n  | DELAY_KEY_WRITE [=] {0 | 1}\n  | ENCRYPTION [=] {\'Y\' | \'N\'}\n  | ENGINE [=] engine_name\n  | ENGINE_ATTRIBUTE [=] \'string\'\n  | INSERT_METHOD [=] { NO | FIRST | LAST }\n  | KEY_BLOCK_SIZE [=] value\n  | MAX_ROWS [=] value\n  | MIN_ROWS [=] value\n  | PACK_KEYS [=] {0 | 1 | DEFAULT}\n  | PASSWORD [=] \'string\'\n  | ROW_FORMAT [=] {DEFAULT | DYNAMIC | FIXED | COMPRESSED | REDUNDANT | COMPACT}\n  | START TRANSACTION \n  | SECONDARY_ENGINE_ATTRIBUTE [=] \'string\'\n  | STATS_AUTO_RECALC [=] {DEFAULT | 0 | 1}\n  | STATS_PERSISTENT [=] {DEFAULT | 0 | 1}\n  | STATS_SAMPLE_PAGES [=] value\n  | tablespace_option\n  | UNION [=] (tbl_name[,tbl_name]...)\n}\n\npartition_options:\n    PARTITION BY\n        { [LINEAR] HASH(expr)\n        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list)\n        | RANGE{(expr) | COLUMNS(column_list)}\n        | LIST{(expr) | COLUMNS(column_list)} }\n    [PARTITIONS num]\n    [SUBPARTITION BY\n        { [LINEAR] HASH(expr)\n        | [LINEAR] KEY [ALGORITHM={1 | 2}] (column_list) }\n      [SUBPARTITIONS num]\n    ]\n    [(partition_definition [, partition_definition] ...)]\n\npartition_definition:\n    PARTITION partition_name\n        [VALUES\n            {LESS THAN {(expr | value_list) | MAXVALUE}\n            |\n            IN (value_list)}]\n        [[STORAGE] ENGINE [=] engine_name]\n        [COMMENT [=] \'string\' ]\n        [DATA DIRECTORY [=] \'data_dir\']\n        [INDEX DIRECTORY [=] \'index_dir\']\n        [MAX_ROWS [=] max_number_of_rows]\n        [MIN_ROWS [=] min_number_of_rows]\n        [TABLESPACE [=] tablespace_name]\n        [(subpartition_definition [, subpartition_definition] ...)]\n\nsubpartition_definition:\n    SUBPARTITION logical_name\n        [[STORAGE] ENGINE [=] engine_name]\n        [COMMENT [=] \'string\' ]\n        [DATA DIRECTORY [=] \'data_dir\']\n        [INDEX DIRECTORY [=] \'index_dir\']\n        [MAX_ROWS [=] max_number_of_rows]\n        [MIN_ROWS [=] min_number_of_rows]\n        [TABLESPACE [=] tablespace_name]\n\ntablespace_option:\n    TABLESPACE tablespace_name [STORAGE DISK]\n  | [TABLESPACE tablespace_name] STORAGE MEMORY\n\nquery_expression:\n    SELECT ...   (Some valid select or union statement)\n\nCREATE TABLE creates a table with the given name. You must have the\nCREATE privilege for the table.\n\nBy default, tables are created in the default database, using the\nInnoDB storage engine. An error occurs if the table exists, if there is\nno default database, or if the database does not exist.\n\nMySQL has no limit on the number of tables. The underlying file system\nmay have a limit on the number of files that represent tables.\nIndividual storage engines may impose engine-specific constraints.\nInnoDB permits up to 4 billion tables.\n\nFor information about the physical representation of a table, see\nhttps://dev.mysql.com/doc/refman/8.4/en/create-table-files.html.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-table.html\n\n','','https://dev.mysql.com/doc/refman/8.4/en/create-table.html'),(522,'FOREIGN KEY',40,'MySQL supports foreign keys, which permit cross-referencing related\ndata across tables, and foreign key constraints, which help keep the\nrelated data consistent.\n\nA foreign key relationship involves a parent table that holds the\ninitial column values, and a child table with column values that\nreference the parent column values. A foreign key constraint is defined\non the child table.\n\nThe essential syntax for a defining a foreign key constraint in a\nCREATE TABLE or ALTER TABLE statement includes the following:\n\n[CONSTRAINT [symbol]] FOREIGN KEY\n    [index_name] (col_name, ...)\n    REFERENCES tbl_name (col_name,...)\n    [ON DELETE reference_option]\n    [ON UPDATE reference_option]\n\nreference_option:\n    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html\n\n','CREATE TABLE product (\n    category INT NOT NULL, id INT NOT NULL,\n    price DECIMAL,\n    PRIMARY KEY(category, id)\n)   ENGINE=INNODB;\n\nCREATE TABLE customer (\n    id INT NOT NULL,\n    PRIMARY KEY (id)\n)   ENGINE=INNODB;\n\nCREATE TABLE product_order (\n    no INT NOT NULL AUTO_INCREMENT,\n    product_category INT NOT NULL,\n    product_id INT NOT NULL,\n    customer_id INT NOT NULL,\n\n    PRIMARY KEY(no),\n    INDEX (product_category, product_id),\n    INDEX (customer_id),\n\n    FOREIGN KEY (product_category, product_id)\n      REFERENCES product(category, id)\n      ON UPDATE CASCADE ON DELETE RESTRICT,\n\n    FOREIGN KEY (customer_id)\n      REFERENCES customer(id)\n)   ENGINE=INNODB;\n','https://dev.mysql.com/doc/refman/8.4/en/create-table-foreign-keys.html'),(523,'CREATE TABLESPACE',40,'Syntax:\nCREATE [UNDO] TABLESPACE tablespace_name\n\n  InnoDB and NDB:\n    [ADD DATAFILE \'file_name\']\n    [AUTOEXTEND_SIZE [=] value]\n\n  InnoDB only:\n    [FILE_BLOCK_SIZE = value]\n    [ENCRYPTION [=] {\'Y\' | \'N\'}]\n\n  NDB only:\n    USE LOGFILE GROUP logfile_group\n    [EXTENT_SIZE [=] extent_size]\n    [INITIAL_SIZE [=] initial_size]\n    [MAX_SIZE [=] max_size]\n    [NODEGROUP [=] nodegroup_id]\n    [WAIT]\n    [COMMENT [=] \'string\']\n\n  InnoDB and NDB:\n    [ENGINE [=] engine_name]\n\n  Reserved for future use:\n    [ENGINE_ATTRIBUTE [=] \'string\']\n\nThis statement is used to create a tablespace. The precise syntax and\nsemantics depend on the storage engine used. In standard MySQL\nreleases, this is always an InnoDB tablespace. MySQL NDB Cluster also\nsupports tablespaces using the NDB storage engine.\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-innodb\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-ndb\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-options\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-notes\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-innodb-examples\n\no https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html#create\n  -tablespace-ndb-examples\n\nConsiderations for InnoDB\n\nCREATE TABLESPACE syntax is used to create general tablespaces or undo\ntablespaces. The UNDO keyword must be specified to create an undo\ntablespace.\n\nA general tablespace is a shared tablespace. It can hold multiple\ntables, and supports all table row formats. General tablespaces can be\ncreated in a location relative to or independent of the data directory.\n\nAfter creating an InnoDB general tablespace, use CREATE TABLE tbl_name\n... TABLESPACE [=] tablespace_name or ALTER TABLE tbl_name TABLESPACE\n[=] tablespace_name to add tables to the tablespace. For more\ninformation, see\nhttps://dev.mysql.com/doc/refman/8.4/en/general-tablespaces.html.\n\nUndo tablespaces contain undo logs. Undo tablespaces can be created in\na chosen location by specifying a fully qualified data file path. For\nmore information, see\nhttps://dev.mysql.com/doc/refman/8.4/en/innodb-undo-tablespaces.html.\n\nConsiderations for NDB Cluster\n\nThis statement is used to create a tablespace, which can contain one or\nmore data files, providing storage space for NDB Cluster Disk Data\ntables (see\nhttps://dev.mysql.com/doc/refman/8.4/en/mysql-cluster-disk-data.html).\nOne data file is created and added to the tablespace using this\nstatement. Additional data files may be added to the tablespace by\nusing the ALTER TABLESPACE statement (see [HELP ALTER TABLESPACE]).\n\n*Note*:\n\nAll NDB Cluster Disk Data objects share the same namespace. This means\nthat each Disk Data object must be uniquely named (and not merely each\nDisk Data object of a given type). For example, you cannot have a\ntablespace and a log file group with the same name, or a tablespace and\na data file with the same name.\n\nA log file group of one or more UNDO log files must be assigned to the\ntablespace to be created with the USE LOGFILE GROUP clause.\nlogfile_group must be an existing log file group created with CREATE\nLOGFILE GROUP (see [HELP CREATE LOGFILE GROUP]). Multiple tablespaces\nmay use the same log file group for UNDO logging.\n\nWhen setting EXTENT_SIZE or INITIAL_SIZE, you may optionally follow the\nnumber with a one-letter abbreviation for an order of magnitude,\nsimilar to those used in my.cnf. Generally, this is one of the letters\nM (for megabytes) or G (for gigabytes).\n\nINITIAL_SIZE and EXTENT_SIZE are subject to rounding as follows:\n\no EXTENT_SIZE is rounded up to the nearest whole multiple of 32K.\n\no INITIAL_SIZE is rounded down to the nearest whole multiple of 32K;\n  this result is rounded up to the nearest whole multiple of\n  EXTENT_SIZE (after any rounding).\n\n*Note*:\n\nNDB reserves 4% of a tablespace for data node restart operations. This\nreserved space cannot be used for data storage.\n\nThe rounding just described is done explicitly, and a warning is issued\nby the MySQL Server when any such rounding is performed. The rounded\nvalues are also used by the NDB kernel for calculating\nINFORMATION_SCHEMA.FILES column values and other purposes. However, to\navoid an unexpected result, we suggest that you always use whole\nmultiples of 32K in specifying these options.\n\nWhen CREATE TABLESPACE is used with ENGINE [=] NDB, a tablespace and\nassociated data file are created on each Cluster data node. You can\nverify that the data files were created and obtain information about\nthem by querying the Information Schema FILES table. (See the example\nlater in this section.)\n\n(See\nhttps://dev.mysql.com/doc/refman/8.4/en/information-schema-files-table.\nhtml.)\n\nOptions\n\no ADD DATAFILE: Defines the name of a tablespace data file. This option\n  is always required when creating an NDB tablespace; for InnoDB, it is\n  required only when creating an undo tablespace. The file_name,\n  including any specified path, must be quoted with single or double\n  quotation marks. File names (not counting the file extension) and\n  directory names must be at least one byte in length. Zero length file\n  names and directory names are not supported.\n\n  Because there are considerable differences in how InnoDB and NDB\n  treat data files, the two storage engines are covered separately in\n  the discussion that follows.\n\n  InnoDB data files An InnoDB tablespace supports only a single data\n  file, whose name must include an .ibd extension.\n\n  To place an InnoDB general tablespace data file in a location outside\n  of the data directory, include a fully qualified path or a path\n  relative to the data directory. Only a fully qualified path is\n  permitted for undo tablespaces. If you do not specify a path, a\n  general tablespace is created in the data directory. An undo\n  tablespace created without specifying a path is created in the\n  directory defined by the innodb_undo_directory variable. If\n  innodb_undo_directory is not set, undo tablespaces are created in the\n  data directory.\n\n  To avoid conflicts with implicitly created file-per-table\n  tablespaces, creating an InnoDB general tablespace in a subdirectory\n  under the data directory is not supported. When creating a general\n  tablespace or undo tablespace outside of the data directory, the\n  directory must exist and must be known to InnoDB prior to creating\n  the tablespace. To make a directory known to InnoDB, add it to the\n  innodb_directories value or to one of the variables whose values are\n  appended to the value of innodb_directories. innodb_directories is a\n  read-only variable. Configuring it requires restarting the server.\n\n  If the ADD DATAFILE clause is not specified when creating an InnoDB\n  tablespace, a tablespace data file with a unique file name is created\n  implicitly. The unique file name is a 128 bit UUID formatted into\n  five groups of hexadecimal numbers separated by dashes\n  (aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee). A file extension is added if\n  required by the storage engine. An .ibd file extension is added for\n  InnoDB general tablespace data files. In a replication environment,\n  the data file name created on the replication source server is not\n  the same as the data file name created on the replica.\n\n  The ADD DATAFILE clause does not permit circular directory references\n  when creating an InnoDB tablespace. For example, the circular\n  directory reference (/../) in the following statement is not\n  permitted:\n\nCREATE TABLESPACE ts1 ADD DATAFILE ts1.ibd \'any_directory/../ts1.ibd\';\n\n  An exception to this restriction exists on Linux, where a circular\n  directory reference is permitted if the preceding directory is a\n  symbolic link. For example, the data file path in the example above\n  is permitted if any_directory is a symbolic link. (It is still\n  permitted for data file paths to begin with \'../\'.)\n\n  NDB data files An NDB tablespace supports multiple data files which\n  can have any legal file names; more data files can be added to an NDB\n  Cluster tablespace following its creation by using an ALTER\n  TABLESPACE statement.\n\n  An NDB tablespace data file is created by default in the data node\n  file system directory---that is, the directory named ndb_nodeid_fs/TS\n  under the data node\'s data directory (DataDir), where nodeid is the\n  data node\'s NodeId. To place the data file in a location other than\n  the default, include an absolute directory path or a path relative to\n  the default location. If the directory specified does not exist, NDB\n  attempts to create it; the system user account under which the data\n  node process is running must have the appropriate permissions to do\n  so.\n\n  *Note*:\n\n  When determining the path used for a data file, NDB does not expand\n  the ~ (tilde) character.\n\n  When multiple data nodes are run on the same physical host, the\n  following considerations apply:\n\n  o You cannot specify an absolute path when creating a data file.\n\n  o It is not possible to create tablespace data files outside the data\n    node file system directory, unless each data node has a separate\n    data directory.\n\n  o If each data node has its own data directory, data files can be\n    created anywhere within this directory.\n\n  o If each data node has its own data directory, it may also be\n    possible to create a data file outside the node\'s data directory\n    using a relative path, as long as this path resolves to a unique\n    location on the host file system for each data node running on that\n    host.\n\no FILE_BLOCK_SIZE: This option---which is specific to InnoDB general\n  tablespaces, and is ignored by NDB---defines the block size for the\n  tablespace data file. Values can be specified in bytes or kilobytes.\n  For example, an 8 kilobyte file block size can be specified as 8192\n  or 8K. If you do not specify this option, FILE_BLOCK_SIZE defaults to\n  the innodb_page_size value. FILE_BLOCK_SIZE is required when you\n  intend to use the tablespace for storing compressed InnoDB tables\n  (ROW_FORMAT=COMPRESSED). In this case, you must define the tablespace\n  FILE_BLOCK_SIZE when creating the tablespace.\n\n  If FILE_BLOCK_SIZE is equal the innodb_page_size value, the\n  tablespace can contain only tables having an uncompressed row format\n  (COMPACT, REDUNDANT, and DYNAMIC). Tables with a COMPRESSED row\n  format have a different physical page size than uncompressed tables.\n  Therefore, compressed tables cannot coexist in the same tablespace as\n  uncompressed tables.\n\n  For a general tablespace to contain compressed tables,\n  FILE_BLOCK_SIZE must be specified, and the FILE_BLOCK_SIZE value must\n  be a valid compressed page size in relation to the innodb_page_size\n  value. Also, the physical page size of the compressed table\n  (KEY_BLOCK_SIZE) must be equal to FILE_BLOCK_SIZE/1024. For example,\n  if innodb_page_size=16K, and FILE_BLOCK_SIZE=8K, the KEY_BLOCK_SIZE\n  of the table must be 8. For more information, see\n  https://dev.mysql.com/doc/refman/8.4/en/general-tablespaces.html.\n\no USE LOGFILE GROUP: Required for NDB, this is the name of a log file\n  group previously created using CREATE LOGFILE GROUP. Not supported\n  for InnoDB, where it fails with an error.\n\no EXTENT_SIZE: This option is specific to NDB, and is not supported by\n  InnoDB, where it fails with an error. EXTENT_SIZE sets the size, in\n  bytes, of the extents used by any files belonging to the tablespace.\n  The default value is 1M. The minimum size is 32K, and theoretical\n  maximum is 2G, although the practical maximum size depends on a\n  number of factors. In most cases, changing the extent size does not\n  have any measurable effect on performance, and the default value is\n  recommended for all but the most unusual situations.\n\n  An extent is a unit of disk space allocation. One extent is filled\n  with as much data as that extent can contain before another extent is\n  used. In theory, up to 65,535 (64K) extents may used per data file;\n  however, the recommended maximum is 32,768 (32K). The recommended\n  maximum size for a single data file is 32G---that is, 32K extents x 1\n  MB per extent. In addition, once an extent is allocated to a given\n  partition, it cannot be used to store data from a different\n  partition; an extent cannot store data from more than one partition.\n  This means, for example that a tablespace having a single datafile\n  whose INITIAL_SIZE (described in the following item) is 256 MB and\n  whose EXTENT_SIZE is 128M has just two extents, and so can be used to\n  store data from at most two different disk data table partitions.\n\n  You can see how many extents remain free in a given data file by\n  querying the Information Schema FILES table, and so derive an\n  estimate for how much space remains free in the file. For further\n  discussion and examples, see\n  https://dev.mysql.com/doc/refman/8.4/en/information-schema-files-tabl\n  e.html.\n\no INITIAL_SIZE: This option is specific to NDB, and is not supported by\n  InnoDB, where it fails with an error.\n\n  The INITIAL_SIZE parameter sets the total size in bytes of the data\n  file that was specific using ADD DATATFILE. Once this file has been\n  created, its size cannot be changed; however, you can add more data\n  files to the tablespace using ALTER TABLESPACE ... ADD DATAFILE.\n\n  INITIAL_SIZE is optional; its default value is 134217728 (128 MB).\n\n  On 32-bit systems, the maximum supported value for INITIAL_SIZE is\n  4294967296 (4 GB).\n\no AUTOEXTEND_SIZE: Defines the amount by which InnoDB extends the size\n  of the tablespace when it becomes full. The setting must be a\n  multiple of 4MB. The default setting is 0, which causes the\n  tablespace to be extended according to the implicit default behavior.\n  For more information, see\n  https://dev.mysql.com/doc/refman/8.4/en/innodb-tablespace-autoextend-\n  size.html.\n\n  Has no effect in any release of MySQL NDB Cluster, regardless of the\n  storage engine used.\n\no MAX_SIZE: Currently ignored by MySQL; reserved for possible future\n  use. Has no effect in any release of MySQL or MySQL NDB Cluster,\n  regardless of the storage engine used.\n\no NODEGROUP: Currently ignored by MySQL; reserved for possible future\n  use. Has no effect in any release of MySQL or MySQL NDB Cluster,\n  regardless of the storage engine used.\n\no WAIT: Currently ignored by MySQL; reserved for possible future use.\n  Has no effect in any release of MySQL or MySQL NDB Cluster,\n  regardless of the storage engine used.\n\no COMMENT: Currently ignored by MySQL; reserved for possible future\n  use. Has no effect in any release of MySQL or MySQL NDB Cluster,\n  regardless of the storage engine used.\n\no The ENCRYPTION clause enables or disables page-level data encryption\n  for an InnoDB general tablespace.\n\n  If the ENCRYPTION clause is not specified, the\n  default_table_encryption setting controls whether encryption is\n  enabled. The ENCRYPTION clause overrides the default_table_encryption\n  setting. However, if the table_encryption_privilege_check variable is\n  enabled, the TABLE_ENCRYPTION_ADMIN privilege is required to use an\n  ENCRYPTION clause setting that differs from the\n  default_table_encryption setting.\n\n  A keyring plugin must be installed and configured before an\n  encryption-enabled tablespace can be created.\n\n  When a general tablespace is encrypted, all tables residing in the\n  tablespace are encrypted. Likewise, a table created in an encrypted\n  tablespace is encrypted.\n\n  For more information, see\n  https://dev.mysql.com/doc/refman/8.4/en/innodb-data-encryption.html\n\no ENGINE: Defines the storage engine which uses the tablespace, where\n  engine_name is the name of the storage engine. Currently, only the\n  InnoDB storage engine is supported by standard MySQL 8.4 releases.\n  MySQL NDB Cluster supports both NDB and InnoDB tablespaces. The value\n  of the default_storage_engine system variable is used for ENGINE if\n  the option is not specified.\n\no The ENGINE_ATTRIBUTE option is used to specify tablespace attributes\n  for primary storage engines. The option is reserved for future use.\n\n  The value assigned to this option must be a string literal containing\n  a valid JSON document or an empty string (\'\'). Invalid JSON is\n  rejected.\n\nCREATE TABLESPACE ts1 ENGINE_ATTRIBUTE=\'{\"key\":\"value\"}\';\n\n  ENGINE_ATTRIBUTE values can be repeated without error. In this case,\n  the last specified value is used.\n\n  ENGINE_ATTRIBUTE values are not checked by the server, nor are they\n  cleared when the table\'s storage engine is changed.\n\nNotes\n\no For the rules covering the naming of MySQL tablespaces, see\n  https://dev.mysql.com/doc/refman/8.4/en/identifiers.html. In addition\n  to these rules, the slash character (\"/\") is not permitted, nor can\n  you use names beginning with innodb_, as this prefix is reserved for\n  system use.\n\no Creation of temporary general tablespaces is not supported.\n\no General tablespaces do not support temporary tables.\n\no The TABLESPACE option may be used with CREATE TABLE or ALTER TABLE to\n  assign an InnoDB table partition or subpartition to a file-per-table\n  tablespace. All partitions must belong to the same storage engine.\n  Assigning table partitions to shared InnoDB tablespaces is not\n  supported. Shared tablespaces include the InnoDB system tablespace\n  and general tablespaces.\n\no General tablespaces support the addition of tables of any row format\n  using CREATE TABLE ... TABLESPACE. innodb_file_per_table does not\n  need to be enabled.\n\no innodb_strict_mode is not applicable to general tablespaces.\n  Tablespace management rules are strictly enforced independently of\n  innodb_strict_mode. If CREATE TABLESPACE parameters are incorrect or\n  incompatible, the operation fails regardless of the\n  innodb_strict_mode setting. When a table is added to a general\n  tablespace using CREATE TABLE ... TABLESPACE or ALTER TABLE ...\n  TABLESPACE, innodb_strict_mode is ignored but the statement is\n  evaluated as if innodb_strict_mode is enabled.\n\no Use DROP TABLESPACE to remove a tablespace. All tables must be\n  dropped from a tablespace using DROP TABLE prior to dropping the\n  tablespace. Before dropping an NDB Cluster tablespace you must also\n  remove all its data files using one or more ALTER TABLESPACE ... DROP\n  DATATFILE statements. See\n  https://dev.mysql.com/doc/refman/8.4/en/mysql-cluster-disk-data-objec\n  ts.html.\n\no All parts of an InnoDB table added to an InnoDB general tablespace\n  reside in the general tablespace, including indexes and BLOB pages.\n\n  For an NDB table assigned to a tablespace, only those columns which\n  are not indexed are stored on disk, and actually use the tablespace\n  data files. Indexes and indexed columns for all NDB tables are always\n  kept in memory.\n\no Similar to the system tablespace, truncating or dropping tables\n  stored in a general tablespace creates free space internally in the\n  general tablespace .ibd data file which can only be used for new\n  InnoDB data. Space is not released back to the operating system as it\n  is for file-per-table tablespaces.\n\no A general tablespace is not associated with any database or schema.\n\no ALTER TABLE ... DISCARD TABLESPACE and ALTER TABLE ...IMPORT\n  TABLESPACE are not supported for tables that belong to a general\n  tablespace.\n\no The server uses tablespace-level metadata locking for DDL that\n  references general tablespaces. By comparison, the server uses\n  table-level metadata locking for DDL that references file-per-table\n  tablespaces.\n\no A generated or existing tablespace cannot be changed to a general\n  tablespace.\n\no There is no conflict between general tablespace names and\n  file-per-table tablespace names. The \"/\" character, which is present\n  in file-per-table tablespace names, is not permitted in general\n  tablespace names.\n\no mysqldump does not dump InnoDB CREATE TABLESPACE statements.\n\nInnoDB Examples\n\nThis example demonstrates creating a general tablespace and adding\nthree uncompressed tables of different row formats.\n\nmysql> CREATE TABLESPACE `ts1` ADD DATAFILE \'ts1.ibd\' ENGINE=INNODB;\n\nmysql> CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=REDUNDANT;\n\nmysql> CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=COMPACT;\n\nmysql> CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;\n\nThis example demonstrates creating a general tablespace and adding a\ncompressed table. The example assumes a default innodb_page_size value\nof 16K. The FILE_BLOCK_SIZE of 8192 requires that the compressed table\nhave a KEY_BLOCK_SIZE of 8.\n\nmysql> CREATE TABLESPACE `ts2` ADD DATAFILE \'ts2.ibd\' FILE_BLOCK_SIZE = 8192 ENGINE=InnoDB;\n\nmysql> CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;\n\nThis example demonstrates creating a general tablespace without\nspecifying the ADD DATAFILE clause, which is optional:\n\nmysql> CREATE TABLESPACE `ts3` ENGINE=INNODB;\n\nThis example demonstrates creating an undo tablespace:\n\nmysql> CREATE UNDO TABLESPACE undo_003 ADD DATAFILE \'undo_003.ibu\';\n\nNDB Example\n\nSuppose that you wish to create an NDB Cluster Disk Data tablespace\nnamed myts using a datafile named mydata-1.dat. An NDB tablespace\nalways requires the use of a log file group consisting of one or more\nundo log files. For this example, we first create a log file group\nnamed mylg that contains one undo long file named myundo-1.dat, using\nthe CREATE LOGFILE GROUP statement shown here:\n\nmysql> CREATE LOGFILE GROUP myg1\n    ->     ADD UNDOFILE \'myundo-1.dat\'\n    ->     ENGINE=NDB;\nQuery OK, 0 rows affected (3.29 sec)\n\nNow you can create the tablespace previously described using the\nfollowing statement:\n\nmysql> CREATE TABLESPACE myts\n    ->     ADD DATAFILE \'mydata-1.dat\'\n    ->     USE LOGFILE GROUP mylg\n    ->     ENGINE=NDB;\nQuery OK, 0 rows affected (2.98 sec)\n\nYou can now create a Disk Data table using a CREATE TABLE statement\nwith the TABLESPACE and STORAGE DISK options, similar to what is shown\nhere:\n\nmysql> CREATE TABLE mytable (\n    ->     id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n    ->     lname VARCHAR(50) NOT NULL,\n    ->     fname VARCHAR(50) NOT NULL,\n    ->     dob DATE NOT NULL,\n    ->     joined DATE NOT NULL,\n    ->     INDEX(last_name, first_name)\n    -> )\n    ->     TABLESPACE myts STORAGE DISK\n    ->     ENGINE=NDB;\nQuery OK, 0 rows affected (1.41 sec)\n\nIt is important to note that only the dob and joined columns from\nmytable are actually stored on disk, due to the fact that the id,\nlname, and fname columns are all indexed.\n\nAs mentioned previously, when CREATE TABLESPACE is used with ENGINE [=]\nNDB, a tablespace and its associated data file are created on each NDB\nCluster data node. You can verify that the data files were created and\nobtain information about them by querying the Information Schema FILES\ntable, as shown here:\n\nmysql> SELECT FILE_NAME, FILE_TYPE, LOGFILE_GROUP_NAME, STATUS, EXTRA\n    ->     FROM INFORMATION_SCHEMA.FILES\n    ->     WHERE TABLESPACE_NAME = \'myts\';\n\n+--------------+------------+--------------------+--------+----------------+\n| file_name    | file_type  | logfile_group_name | status | extra          |\n+--------------+------------+--------------------+--------+----------------+\n| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=5 |\n| mydata-1.dat | DATAFILE   | mylg               | NORMAL | CLUSTER_NODE=6 |\n| NULL         | TABLESPACE | mylg               | NORMAL | NULL           |\n+--------------+------------+--------------------+--------+----------------+\n3 rows in set (0.01 sec)\n\nFor additional information and examples, see\nhttps://dev.mysql.com/doc/refman/8.4/en/mysql-cluster-disk-data-objects\n.html.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html\n\n','','https://dev.mysql.com/doc/refman/8.4/en/create-tablespace.html'),(524,'CREATE TRIGGER',40,'Syntax:\nCREATE\n    [DEFINER = user]\n    TRIGGER [IF NOT EXISTS] trigger_name\n    trigger_time trigger_event\n    ON tbl_name FOR EACH ROW\n    [trigger_order]\n    trigger_body\n\ntrigger_time: { BEFORE | AFTER }\n\ntrigger_event: { INSERT | UPDATE | DELETE }\n\ntrigger_order: { FOLLOWS | PRECEDES } other_trigger_name\n\nThis statement creates a new trigger. A trigger is a named database\nobject that is associated with a table, and that activates when a\nparticular event occurs for the table. The trigger becomes associated\nwith the table named tbl_name, which must refer to a permanent table.\nYou cannot associate a trigger with a TEMPORARY table or a view.\n\nTrigger names exist in the schema namespace, meaning that all triggers\nmust have unique names within a schema. Triggers in different schemas\ncan have the same name.\n\nIF NOT EXISTS prevents an error from occurring if a trigger having the\nsame name, on the same table, exists in the same schema.\n\nThis section describes CREATE TRIGGER syntax. For additional\ndiscussion, see\nhttps://dev.mysql.com/doc/refman/8.4/en/trigger-syntax.html.\n\nCREATE TRIGGER requires the TRIGGER privilege for the table associated\nwith the trigger. If the DEFINER clause is present, the privileges\nrequired depend on the user value, as discussed in\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-objects-security.html.\nIf binary logging is enabled, CREATE TRIGGER might require the SUPER\nprivilege, as discussed in\nhttps://dev.mysql.com/doc/refman/8.4/en/stored-programs-logging.html.\n\nThe DEFINER clause determines the security context to be used when\nchecking access privileges at trigger activation time, as described\nlater in this section.\n\ntrigger_time is the trigger action time. It can be BEFORE or AFTER to\nindicate that the trigger activates before or after each row to be\nmodified.\n\nBasic column value checks occur prior to trigger activation, so you\ncannot use BEFORE triggers to convert values inappropriate for the\ncolumn type to valid values.\n\ntrigger_event indicates the kind of operation that activates the\ntrigger. These trigger_event values are permitted:\n\no INSERT: The trigger activates whenever a new row is inserted into the\n  table (for example, through INSERT, LOAD DATA, and REPLACE\n  statements).\n\no UPDATE: The trigger activates whenever a row is modified (for\n  example, through UPDATE statements).\n\no DELETE: The trigger activates whenever a row is deleted from the\n  table (for example, through DELETE and REPLACE statements). DROP\n  TABLE and TRUNCATE TABLE statements on the table do not activate this\n  trigger, because they do not use DELETE. Dropping a partition does\n  not activate DELETE triggers, either.\n\nURL: https://dev.mysql.com/doc/refman/8.4/en/create-trigger.html\n\n','','https://dev.mysql.com/doc/refman/8.4/en/create-trigger.html'),(525,'CREATE VIEW',40,'Syntax:\nCREATE\n    [OR REPLACE]\n    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]\n    [DEFINER = user]\n    [SQL SECURITY { DEFINER | INVOKER }]\n    VIEW view_name [(column_list)]\n    AS select_statement\n    [WITH [CASCADED | LOCAL] CHECK OPTION]\n\nThe CREATE VIEW statement creates a new view, or replaces an existing\nview if the OR REPLACE clause is given. If the view does not exist,\nCREATE OR REPLACE VIEW is the same as CREATE VIEW. If the view does\nexist, CREATE OR REPLACE VIEW replaces it.\n\nFor information about restrictions on view use, see\nhttps://dev.mysql.com/doc/refman/8.4/en/view-restrictions.html.\n\nThe select_statement is a SELECT statement that provides the definition\nof the view. (Selecting from the view selects, in effect, using the\nSELECT statement.) The select_statement can select from base tables or\nfrom other views. The SELECT statement can use a VALUES statement as\nits source, or can be replaced with a TABLE statement, as with CREATE\nTABLE ... SELECT.\n\nThe view definition is \"frozen\" at creation time and is not affected by\nsubsequent changes to the definitions of the underlying tables. For\nexample, if a view is defined as SELECT * on a table, new columns added\nto the table later do not become part of the view, and columns dropped\nfrom the table result in an error when selecting from the view.\n\nThe ALGORITHM clause affects how MySQL processes the view. The DEFINER\nand SQL SECURITY clauses specify the security context to be used when\nchecking access privileges at vi